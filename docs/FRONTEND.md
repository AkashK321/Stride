# Stride Frontend

React Native mobile application built with Expo and Expo Router.

## Prerequisites

- Node.js (v18 or higher)
- npm or yarn
- Expo CLI (installed globally or via npx)

## Setup

1. **Install dependencies:**

   ```bash
   cd frontend
   npm install
   ```

2. **Configure environment variables:**
   
   Create a `.env` file in the `frontend/` directory:
   ```bash
   cp .env.example .env
   ```
   
   Edit `.env` and set the `EXPO_PUBLIC_API_BASE_URL` variable:
   ```
   EXPO_PUBLIC_API_BASE_URL=https://your-api-gateway-url.execute-api.us-east-1.amazonaws.com/prod
   ```
   
   See [Finding Your API Gateway URL](#finding-your-api-gateway-url) below for how to get this URL.
   
   **Note:** The `.env` file is git-ignored and should not be committed to version control.

3. **Start the development server:**

   ```bash
   npm start
   ```
   
   Or for a specific platform:
   ```bash
   npm run ios      # iOS simulator
   npm run android  # Android emulator
   npm run web      # Web browser
   ```

You can open the app in:

- **Expo Go** (quick device testing)
- **iOS simulator** / **Android emulator**
- A **development build** if you add native modules later

## Environment Variables

### Required

- `EXPO_PUBLIC_API_BASE_URL` - The base URL for the API Gateway REST API endpoint
  - Must be set in `.env` file
  - Format: `https://xxxxx.execute-api.us-east-1.amazonaws.com/prod`
  - No trailing slash

- `EXPO_PUBLIC_WS_API_URL` - The WebSocket API Gateway URL for navigation frame transmission
  - Must be set in `.env` file
  - Format: `wss://xxxxx.execute-api.us-east-1.amazonaws.com/prod`
  - No trailing slash

### Optional

- `EXPO_PUBLIC_DEV_LOGGER_URL` - Development CSV logger server URL (dev mode only)
  - Only needed if you want to log WebSocket responses to CSV files
  - Format: `http://<your-laptop-ip>:3001/log`
  - Example: `http://192.168.1.100:3001/log`
  - See [Development CSV Logger](#development-csv-logger) section for setup instructions

### Expo Environment Variables

In Expo, environment variables prefixed with `EXPO_PUBLIC_` are exposed to client-side code. This is necessary for the API base URL since it's used in the React Native app.

**Important:** After modifying `.env` file, you must restart the Expo development server for changes to take effect:

```bash
cd frontend
npx expo start --clear
```

## Connecting to a Live Backend

A developer must set the `EXPO_PUBLIC_API_BASE_URL` environment variable in order to connect the frontend to the backend and test against live endpoints. Without this variable set, the app will throw an error on startup (unless using [Developer Bypass](#developer-bypass)).

### Finding Your API Gateway URL

There are two ways to find the URL depending on how the stack was deployed:

#### Option A: From CI/CD Pipeline Output

1. Go to the **GitHub Actions** tab in the repository
2. Find the **Infrastructure Deploy** workflow run for your branch
3. Click on the **Deploy Infrastructure** job
4. Open the **Job Summary** tab — the REST API Endpoint URL is displayed under **Stack Outputs**
5. Alternatively, expand the **Get stack outputs** step in the logs — look for:
   ```
   ✅ REST API Endpoint: https://<api-id>.execute-api.us-east-1.amazonaws.com/prod/
   ```

#### Option B: From Manual CDK Deployment

If you deployed manually using `cdk deploy`, the URL is printed in the terminal output at the end of deployment. You can also find it in the `cdk-outputs.json` file generated by the deploy:

```bash
cd aws_resources
cat cdk-outputs.json | jq '.[].RestAPIEndpointURL'
```

Or retrieve it from CloudFormation directly:

```bash
aws cloudformation describe-stacks \
  --stack-name <your-stack-name> \
  --query "Stacks[0].Outputs[?OutputKey=='RestAPIEndpointURL'].OutputValue" \
  --output text
```

The stack name follows this pattern:
- **Main branch**: `StrideStack`
- **Feature branches**: `StrideStack-<issue-number>-<description>`

### Setting the URL

Once you have the URL, open `frontend/.env` and set it:

```
EXPO_PUBLIC_API_BASE_URL=https://<api-id>.execute-api.us-east-1.amazonaws.com/prod
```

Then restart Expo for the change to take effect:

```bash
npx expo start --clear
```

### Developer Bypass

If you are making **frontend-only changes** and do not need a live backend, you can use the **Developer Bypass** button on the login screen. This button is only visible in development builds (`__DEV__ === true`) and will never appear in production.

When you press the button:
1. A notification popup appears explaining that no live backend endpoint is configured
2. It reminds you that to test with a live backend you must deploy a stack and log in with real credentials
3. After dismissing the popup, you are navigated into the main tab view where you can test frontend changes

This allows frontend developers to iterate on UI/UX without deploying a backend stack.

## Development

- **Linting:** `npm run lint`
- **Type checking:** TypeScript is configured and will show errors in your IDE

### Development CSV Logger

The dev logger is a development-only tool that logs WebSocket responses to CSV files on your laptop for analysis. This is useful for debugging latency, response patterns, and object detection results.

#### Setup

1. **Start the dev logger server** (in a separate terminal):
   ```bash
   cd frontend
   npm run dev-logger
   ```
   
   The server will display:
   - The localhost URL: `http://localhost:3001`
   - Your laptop's network IP address (e.g., `http://192.168.1.100:3001`)
   - Instructions for configuring the `.env` file

2. **Configure for physical devices** (if using Expo Go on a physical device):
   
   Add to your `.env` file:
   ```
   EXPO_PUBLIC_DEV_LOGGER_URL=http://YOUR_LAPTOP_IP:3001/log
   ```
   
   Replace `YOUR_LAPTOP_IP` with the IP address shown by the logger server.
   
   **Note:** If using an emulator/simulator, you can skip this step as `localhost` will work automatically.

3. **Restart Expo server** after adding the env var:
   ```bash
   npx expo start --clear
   ```

4. **Use your app** — responses will automatically be logged to CSV files in `frontend/dev-logs/`

5. **Stop the logger** when done by pressing `Ctrl+C` in the logger server terminal

#### CSV File Format

Each CSV file contains the following columns:
- `timestamp` - When the response was received
- `request_id` - Request ID for correlation with sent frames
- `latency_ms` - Calculated request-response latency
- `frame_size` - Size of the image frame in bytes
- `valid` - Whether the image was valid (true/false)
- `estimated_distances_count` - Number of detected objects
- `estimated_distances_json` - Full detection results as JSON
- `type` - Response type (if any)
- `error` - Error message (if any)
- `status` - Response status
- `full_response_json` - Complete response payload for debugging

Files are named: `responses-{session_id}-{timestamp}.csv`

#### Notes

- The logger only works in development mode (`__DEV__ === true`)
- If the logger server isn't running, the app will continue to work normally (it fails silently)
- CSV files are written to `frontend/dev-logs/` (this directory is git-ignored)
- The logger server must be running before responses can be logged

### Navigation Screen UI

The navigation screen provides a camera-based interface for indoor navigation with the following features:

#### Controls

- **Send Frame Button** - Manually capture and send a single camera frame with sensor data to the backend
- **Play/Stop Button** - Toggle continuous navigation mode that automatically captures and sends frames at a configurable interval
- **Settings Button** - Opens an inline settings panel to configure:
  - **Image Width** - Frame capture width in pixels (default: 360px)
  - **JPEG Quality** - Image compression quality from 0.1 to 1.0 (default: 0.5)
  - **Send Frequency** - Interval between automatic frame captures (default: 0.5s, options: 0.5s, 1s, 2s, 5s)

**Note:** Settings are disabled and cannot be changed while continuous navigation is active. The settings panel automatically closes when navigation starts.

#### Data Display

The screen includes two tabs for viewing sent and received data:

- **Sent Tab** - Displays the raw JSON payload of the last sent frame, including:
  - Image data (base64 encoded)
  - Sensor readings (GPS, accelerometer, gyroscope, heading)
  - Frame metadata (width, quality, timestamp, request ID)
  - Image preview below the JSON data

- **Response Tab** - Displays the raw JSON response from the backend, including:
  - Object detection results
  - Estimated distances
  - Request ID and calculated latency
  - Frame validation status

Both tabs use syntax-highlighted JSON formatting with color-coded keys, strings, numbers, and booleans for improved readability.

#### Frame Counter

A header displays the total number of frames sent during the current session.

## Building

For production builds, see the [Expo documentation](https://docs.expo.dev/build/introduction/).

## Project Structure

### File structure overview

```text
frontend/
├─ app/                         # App screens and navigation (expo-router)
│  ├─ _layout.tsx               # Root layout: wraps all routes in a Stack navigator
│  ├─ (auth)/                   # Auth-related routes (landing, login, reset flows)
│  │  ├─ _layout.tsx            # Auth stack layout (no tabs; auth-specific config)
│  │  └─ index.tsx              # Auth landing screen with "Sign in" button
│  └─ (tabs)/                   # Main app routes behind the tab bar
│     ├─ _layout.tsx            # Tabs layout: defines home/profile/settings tabs
│     ├─ home.tsx               # Home tab screen
│     ├─ profile.tsx            # Profile tab screen
│     └─ settings.tsx           # Settings tab screen
├─ assets/                      # Static assets bundled with the app
│  ├─ fonts/                    # Custom fonts (currently empty)
│  ├─ icons/                    # Vector or PNG icons (currently empty)
│  └─ images/                   # App images, logos, splash artwork
├─ components/                  # Reusable presentational and form components
│  ├─ Button/                   # Reusable button used on the landing screen
│  │  ├─ Button.tsx             # Button implementation (non-JSX React.createElement)
│  │  ├─ index.ts               # Barrel export for the Button component
│  │  └─ styles.ts              # Button-specific style helpers
│  ├─ Label/                    # Text label component
│  │  ├─ Label.tsx              # Label implementation
│  │  ├─ index.ts               # Barrel export for Label
│  │  └─ styles.ts              # Label-specific style helpers
│  └─ TextField/                # Input field component
│     ├─ TextField.tsx          # TextField implementation
│     ├─ index.ts               # Barrel export for TextField
│     └─ styles.ts              # TextField-specific style helpers
├─ hooks/                       # Custom React hooks (placeholder for app logic)
├─ services/                    # API clients and integration with backend services
├─ theme/                       # Design system tokens and theme utilities
│  ├─ colors.ts                 # Central color palette (brand, semantic colors)
│  ├─ radius.ts                 # Border radius scale
│  ├─ spacing.ts                # Spacing scale (margins/padding)
│  ├─ typography.ts             # Font sizes, weights, and text styles
│  └─ index.ts                  # Theme barrel exports / helpers
├─ contexts/                    # React contexts (AuthContext, etc.)
├─ services/                    # API and business logic services
│  ├─ api.ts                    # API client for backend requests
│  └─ tokenStorage.ts           # Secure token storage and refresh logic
├─ types/                       # Shared TypeScript types and interfaces
├─ utils/                       # Small, pure utility functions and helpers
├─ app.json                     # Expo app configuration (name, icons, splash, etc.)
├─ .env                         # Environment variables (not committed)
├─ .env.example                 # Environment variable template
├─ eslint.config.js             # ESLint configuration
├─ expo-env.d.ts                # Expo environment type declarations
├─ package.json                 # Frontend dependencies and scripts
└─ tsconfig.json                # TypeScript configuration
```

---

### Core directories (detailed)

#### `app/`

The `app` directory is the heart of the frontend and uses **file-based routing** via `expo-router`.

- Each file in `app` becomes a **screen**.
- Folders wrapped in parentheses (like `(auth)` and `(tabs)`) are **route groups**:
  they organize screens without affecting the URL path.
- `_layout.tsx` files define **navigation layouts** (Stacks, Tabs, etc.) for their subtree.

In Stride:

- The **root** `_layout.tsx` wraps the entire app in a `Stack` navigator.
- `(auth)/` holds the **unauthenticated flow** (landing now, later login/forgot/reset).
- `(tabs)/` holds the **main tabbed experience** shown after "Sign in".

#### `assets/`

Static assets that ship with the app:

- **images/**: icons, logos, splash screens, and any other raster assets.
- **fonts/**: custom fonts to be loaded via `expo-font`.
- **icons/**: reusable icon assets (SVGs/PNGs) if you choose to add them.

Treat this as the single place for non-code resources to keep imports consistent and cacheable.

#### `components/`

Reusable building blocks for your UI:

- **Button/**: shared button used on the landing page and elsewhere.
- **Label/**: text labels that can be reused across forms and screens.
- **TextField/**: input components for forms and settings.

Each component folder typically contains:

- `*.tsx` – the implementation
- `styles.ts` – any style helpers specific to that component
- `index.ts` – a barrel file so imports stay clean (`import Button from "../components/Button"`).

Over time, this is where you'll add more UI primitives (cards, modals, lists, etc.).

#### `hooks/`

Custom React hooks live here, for example:

- `useAuth` – manage auth state and tokens.
- `useTheme` – read/update theme preferences (light/dark/system).
- `useDebouncedValue`, `usePaginatedQuery`, etc.

Keeping hooks in one place makes it easier to share logic across screens without bloating components.

#### `services/`

Integration points with external systems:

- **`api.ts`**: HTTP client for backend API requests (login, register, token refresh)
- **`tokenStorage.ts`**: Secure token storage using `expo-secure-store` and automatic token refresh logic
- Analytics, logging, feature flags, or any other side-effectful services.

By routing all external calls through `services`, components and hooks stay focused on UI and state, not on networking details.

#### `contexts/`

React Context providers for global application state:

- **`AuthContext.tsx`**: Manages authentication state, login/logout, and token refresh across the app

Contexts provide a way to share state and functions across components without prop drilling.

#### `theme/`

Your design system and visual tokens:

- `colors.ts` – brand palette and semantic colors (success, error, background, etc.).
- `spacing.ts` – a consistent spacing scale (`xs`, `sm`, `md`, etc.).
- `radius.ts` – a scale for rounded corners.
- `typography.ts` – font sizes, weights, and text presets.
- `index.ts` – a central export point and any helpers (e.g., `makeTextStyle`).

This keeps styling consistent and makes large-scale visual changes much easier.

#### `types/`

Project-wide TypeScript types and interfaces:

- Domain models (e.g., `User`, `Workout`, `Goal`).
- Shared enums/constants shapes.
- Response/request shapes for APIs (often in tandem with `services`).

Centralizing shared types reduces duplication and keeps contracts in one place.

---

---

### Why abstract components, assets, and themes?

Instead of defining styles, colors, and UI elements directly inside each screen, we organize them into dedicated directories. This approach makes the codebase easier to maintain and scale. When you need to change a button's appearance or update the brand color, you only update it in one place rather than hunting through dozens of files. Components become reusable building blocks that keep the UI consistent across the app, while centralized themes ensure that spacing, colors, and typography follow a cohesive design system. Assets are kept separate so they can be optimized, cached, and referenced consistently. As the app grows, this structure makes it much easier to find what you're looking for, test individual pieces, and make sweeping changes without breaking things.

---

## Troubleshooting

### "EXPO_PUBLIC_API_BASE_URL environment variable is not set"

- Ensure you have created a `.env` file in the `frontend/` directory
- Verify the file contains `EXPO_PUBLIC_API_BASE_URL=your-url-here`
- Restart the Expo development server after creating/modifying `.env`
- Check that there are no typos in the variable name

### API requests failing

- Verify the `EXPO_PUBLIC_API_BASE_URL` is correct
- Check that the API Gateway is deployed and accessible
- Ensure the URL doesn't have a trailing slash
- Check network connectivity and CORS settings on the API Gateway

### Other Issues

- **Metro bundler cache issues:** Try clearing the cache with `npx expo start --clear`
- **TypeScript errors:** Ensure all dependencies are installed and run `npm install` again
- **Expo Go limitations:** Some features (like secure storage) may have limitations in Expo Go; consider using a development build

## Learn More

To learn more about developing with Expo and `expo-router`, see:

- [Expo documentation](https://docs.expo.dev/)
- [Expo Router introduction](https://docs.expo.dev/router/introduction)
- [Learn Expo tutorial](https://docs.expo.dev/tutorial/introduction/)

